// Code generated by go-swagger; DO NOT EDIT.

package kbmodel

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Subscription subscription
// swagger:model Subscription
type Subscription struct {

	// account Id
	AccountID strfmt.UUID `json:"accountId,omitempty"`

	// audit logs
	AuditLogs []*AuditLog `json:"auditLogs"`

	// bill cycle day local
	BillCycleDayLocal int32 `json:"billCycleDayLocal,omitempty"`

	// billing end date
	BillingEndDate strfmt.Date `json:"billingEndDate,omitempty"`

	// billing period
	// Required: true
	BillingPeriod *string `json:"billingPeriod"`

	// billing start date
	BillingStartDate strfmt.Date `json:"billingStartDate,omitempty"`

	// bundle Id
	BundleID strfmt.UUID `json:"bundleId,omitempty"`

	// cancelled date
	CancelledDate strfmt.Date `json:"cancelledDate,omitempty"`

	// charged through date
	ChargedThroughDate strfmt.Date `json:"chargedThroughDate,omitempty"`

	// events
	Events []*EventSubscription `json:"events"`

	// external key
	ExternalKey string `json:"externalKey,omitempty"`

	// phase type
	PhaseType string `json:"phaseType,omitempty"`

	// plan name
	// Required: true
	PlanName *string `json:"planName"`

	// price list
	// Required: true
	PriceList *string `json:"priceList"`

	// price overrides
	PriceOverrides []*PhasePrice `json:"priceOverrides"`

	// prices
	Prices []*PhasePrice `json:"prices"`

	// product category
	ProductCategory string `json:"productCategory,omitempty"`

	// product name
	// Required: true
	ProductName *string `json:"productName"`

	// source type
	SourceType string `json:"sourceType,omitempty"`

	// start date
	StartDate strfmt.Date `json:"startDate,omitempty"`

	// state
	State string `json:"state,omitempty"`

	// subscription Id
	SubscriptionID strfmt.UUID `json:"subscriptionId,omitempty"`
}

// Validate validates this subscription
func (m *Subscription) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateAuditLogs(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBillingEndDate(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBillingPeriod(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBillingStartDate(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBundleID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCancelledDate(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateChargedThroughDate(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateEvents(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePhaseType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePlanName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePriceList(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePriceOverrides(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePrices(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProductCategory(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProductName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSourceType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStartDate(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSubscriptionID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Subscription) validateAccountID(formats strfmt.Registry) error {

	if swag.IsZero(m.AccountID) { // not required
		return nil
	}

	if err := validate.FormatOf("accountId", "body", "uuid", m.AccountID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validateAuditLogs(formats strfmt.Registry) error {

	if swag.IsZero(m.AuditLogs) { // not required
		return nil
	}

	for i := 0; i < len(m.AuditLogs); i++ {

		if swag.IsZero(m.AuditLogs[i]) { // not required
			continue
		}

		if m.AuditLogs[i] != nil {

			if err := m.AuditLogs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("auditLogs" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (m *Subscription) validateBillingEndDate(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingEndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("billingEndDate", "body", "date", m.BillingEndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var subscriptionTypeBillingPeriodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DAILY","WEEKLY","BIWEEKLY","THIRTY_DAYS","SIXTY_DAYS","NINETY_DAYS","MONTHLY","BIMESTRIAL","QUARTERLY","TRIANNUAL","BIANNUAL","ANNUAL","BIENNIAL","NO_BILLING_PERIOD"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionTypeBillingPeriodPropEnum = append(subscriptionTypeBillingPeriodPropEnum, v)
	}
}

const (

	// SubscriptionBillingPeriodDAILY captures enum value "DAILY"
	SubscriptionBillingPeriodDAILY string = "DAILY"

	// SubscriptionBillingPeriodWEEKLY captures enum value "WEEKLY"
	SubscriptionBillingPeriodWEEKLY string = "WEEKLY"

	// SubscriptionBillingPeriodBIWEEKLY captures enum value "BIWEEKLY"
	SubscriptionBillingPeriodBIWEEKLY string = "BIWEEKLY"

	// SubscriptionBillingPeriodTHIRTYDAYS captures enum value "THIRTY_DAYS"
	SubscriptionBillingPeriodTHIRTYDAYS string = "THIRTY_DAYS"

	// SubscriptionBillingPeriodSIXTYDAYS captures enum value "SIXTY_DAYS"
	SubscriptionBillingPeriodSIXTYDAYS string = "SIXTY_DAYS"

	// SubscriptionBillingPeriodNINETYDAYS captures enum value "NINETY_DAYS"
	SubscriptionBillingPeriodNINETYDAYS string = "NINETY_DAYS"

	// SubscriptionBillingPeriodMONTHLY captures enum value "MONTHLY"
	SubscriptionBillingPeriodMONTHLY string = "MONTHLY"

	// SubscriptionBillingPeriodBIMESTRIAL captures enum value "BIMESTRIAL"
	SubscriptionBillingPeriodBIMESTRIAL string = "BIMESTRIAL"

	// SubscriptionBillingPeriodQUARTERLY captures enum value "QUARTERLY"
	SubscriptionBillingPeriodQUARTERLY string = "QUARTERLY"

	// SubscriptionBillingPeriodTRIANNUAL captures enum value "TRIANNUAL"
	SubscriptionBillingPeriodTRIANNUAL string = "TRIANNUAL"

	// SubscriptionBillingPeriodBIANNUAL captures enum value "BIANNUAL"
	SubscriptionBillingPeriodBIANNUAL string = "BIANNUAL"

	// SubscriptionBillingPeriodANNUAL captures enum value "ANNUAL"
	SubscriptionBillingPeriodANNUAL string = "ANNUAL"

	// SubscriptionBillingPeriodBIENNIAL captures enum value "BIENNIAL"
	SubscriptionBillingPeriodBIENNIAL string = "BIENNIAL"

	// SubscriptionBillingPeriodNOBILLINGPERIOD captures enum value "NO_BILLING_PERIOD"
	SubscriptionBillingPeriodNOBILLINGPERIOD string = "NO_BILLING_PERIOD"
)

// prop value enum
func (m *Subscription) validateBillingPeriodEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionTypeBillingPeriodPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Subscription) validateBillingPeriod(formats strfmt.Registry) error {

	if err := validate.Required("billingPeriod", "body", m.BillingPeriod); err != nil {
		return err
	}

	// value enum
	if err := m.validateBillingPeriodEnum("billingPeriod", "body", *m.BillingPeriod); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validateBillingStartDate(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingStartDate) { // not required
		return nil
	}

	if err := validate.FormatOf("billingStartDate", "body", "date", m.BillingStartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validateBundleID(formats strfmt.Registry) error {

	if swag.IsZero(m.BundleID) { // not required
		return nil
	}

	if err := validate.FormatOf("bundleId", "body", "uuid", m.BundleID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validateCancelledDate(formats strfmt.Registry) error {

	if swag.IsZero(m.CancelledDate) { // not required
		return nil
	}

	if err := validate.FormatOf("cancelledDate", "body", "date", m.CancelledDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validateChargedThroughDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ChargedThroughDate) { // not required
		return nil
	}

	if err := validate.FormatOf("chargedThroughDate", "body", "date", m.ChargedThroughDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validateEvents(formats strfmt.Registry) error {

	if swag.IsZero(m.Events) { // not required
		return nil
	}

	for i := 0; i < len(m.Events); i++ {

		if swag.IsZero(m.Events[i]) { // not required
			continue
		}

		if m.Events[i] != nil {

			if err := m.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("events" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

var subscriptionTypePhaseTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TRIAL","DISCOUNT","FIXEDTERM","EVERGREEN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionTypePhaseTypePropEnum = append(subscriptionTypePhaseTypePropEnum, v)
	}
}

const (

	// SubscriptionPhaseTypeTRIAL captures enum value "TRIAL"
	SubscriptionPhaseTypeTRIAL string = "TRIAL"

	// SubscriptionPhaseTypeDISCOUNT captures enum value "DISCOUNT"
	SubscriptionPhaseTypeDISCOUNT string = "DISCOUNT"

	// SubscriptionPhaseTypeFIXEDTERM captures enum value "FIXEDTERM"
	SubscriptionPhaseTypeFIXEDTERM string = "FIXEDTERM"

	// SubscriptionPhaseTypeEVERGREEN captures enum value "EVERGREEN"
	SubscriptionPhaseTypeEVERGREEN string = "EVERGREEN"
)

// prop value enum
func (m *Subscription) validatePhaseTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionTypePhaseTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Subscription) validatePhaseType(formats strfmt.Registry) error {

	if swag.IsZero(m.PhaseType) { // not required
		return nil
	}

	// value enum
	if err := m.validatePhaseTypeEnum("phaseType", "body", m.PhaseType); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validatePlanName(formats strfmt.Registry) error {

	if err := validate.Required("planName", "body", m.PlanName); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validatePriceList(formats strfmt.Registry) error {

	if err := validate.Required("priceList", "body", m.PriceList); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validatePriceOverrides(formats strfmt.Registry) error {

	if swag.IsZero(m.PriceOverrides) { // not required
		return nil
	}

	for i := 0; i < len(m.PriceOverrides); i++ {

		if swag.IsZero(m.PriceOverrides[i]) { // not required
			continue
		}

		if m.PriceOverrides[i] != nil {

			if err := m.PriceOverrides[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("priceOverrides" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (m *Subscription) validatePrices(formats strfmt.Registry) error {

	if swag.IsZero(m.Prices) { // not required
		return nil
	}

	for i := 0; i < len(m.Prices); i++ {

		if swag.IsZero(m.Prices[i]) { // not required
			continue
		}

		if m.Prices[i] != nil {

			if err := m.Prices[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("prices" + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

var subscriptionTypeProductCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BASE","ADD_ON","STANDALONE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionTypeProductCategoryPropEnum = append(subscriptionTypeProductCategoryPropEnum, v)
	}
}

const (

	// SubscriptionProductCategoryBASE captures enum value "BASE"
	SubscriptionProductCategoryBASE string = "BASE"

	// SubscriptionProductCategoryADDON captures enum value "ADD_ON"
	SubscriptionProductCategoryADDON string = "ADD_ON"

	// SubscriptionProductCategorySTANDALONE captures enum value "STANDALONE"
	SubscriptionProductCategorySTANDALONE string = "STANDALONE"
)

// prop value enum
func (m *Subscription) validateProductCategoryEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionTypeProductCategoryPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Subscription) validateProductCategory(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductCategory) { // not required
		return nil
	}

	// value enum
	if err := m.validateProductCategoryEnum("productCategory", "body", m.ProductCategory); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validateProductName(formats strfmt.Registry) error {

	if err := validate.Required("productName", "body", m.ProductName); err != nil {
		return err
	}

	return nil
}

var subscriptionTypeSourceTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NATIVE","MIGRATED","TRANSFERRED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionTypeSourceTypePropEnum = append(subscriptionTypeSourceTypePropEnum, v)
	}
}

const (

	// SubscriptionSourceTypeNATIVE captures enum value "NATIVE"
	SubscriptionSourceTypeNATIVE string = "NATIVE"

	// SubscriptionSourceTypeMIGRATED captures enum value "MIGRATED"
	SubscriptionSourceTypeMIGRATED string = "MIGRATED"

	// SubscriptionSourceTypeTRANSFERRED captures enum value "TRANSFERRED"
	SubscriptionSourceTypeTRANSFERRED string = "TRANSFERRED"
)

// prop value enum
func (m *Subscription) validateSourceTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionTypeSourceTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Subscription) validateSourceType(formats strfmt.Registry) error {

	if swag.IsZero(m.SourceType) { // not required
		return nil
	}

	// value enum
	if err := m.validateSourceTypeEnum("sourceType", "body", m.SourceType); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validateStartDate(formats strfmt.Registry) error {

	if swag.IsZero(m.StartDate) { // not required
		return nil
	}

	if err := validate.FormatOf("startDate", "body", "date", m.StartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var subscriptionTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PENDING","ACTIVE","BLOCKED","CANCELLED","EXPIRED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subscriptionTypeStatePropEnum = append(subscriptionTypeStatePropEnum, v)
	}
}

const (

	// SubscriptionStatePENDING captures enum value "PENDING"
	SubscriptionStatePENDING string = "PENDING"

	// SubscriptionStateACTIVE captures enum value "ACTIVE"
	SubscriptionStateACTIVE string = "ACTIVE"

	// SubscriptionStateBLOCKED captures enum value "BLOCKED"
	SubscriptionStateBLOCKED string = "BLOCKED"

	// SubscriptionStateCANCELLED captures enum value "CANCELLED"
	SubscriptionStateCANCELLED string = "CANCELLED"

	// SubscriptionStateEXPIRED captures enum value "EXPIRED"
	SubscriptionStateEXPIRED string = "EXPIRED"
)

// prop value enum
func (m *Subscription) validateStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subscriptionTypeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Subscription) validateState(formats strfmt.Registry) error {

	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *Subscription) validateSubscriptionID(formats strfmt.Registry) error {

	if swag.IsZero(m.SubscriptionID) { // not required
		return nil
	}

	if err := validate.FormatOf("subscriptionId", "body", "uuid", m.SubscriptionID.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Subscription) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Subscription) UnmarshalBinary(b []byte) error {
	var res Subscription
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
